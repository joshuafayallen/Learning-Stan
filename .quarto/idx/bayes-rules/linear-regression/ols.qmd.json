{"title":"Linear Regression Stan","markdown":{"yaml":{"title":"Linear Regression Stan","format":"html"},"headingText":"Tuning  a model.","containsRefs":false,"markdown":"\n\n\n```{r}\nlibrary(bayesrules)\nlibrary(tidyverse)\nlibrary(brms)\nlibrary(cmdstanr)\nlibrary(broom.mixed)\nlibrary(tidybayes)\nlibrary(ggdist)\nlibrary(patchwork)\nlibrary(ggtext)\n\nset.seed(1994)\n\ndata(bikes, package = \"bayesrules\")\n\n\nbikes <- bikes |>\n  mutate(\n    temp_feel_centered = scale(temp_feel, scale = FALSE),\n    temp_feel_c = as.numeric(temp_feel_centered)\n  )\n\n\ntemp_details <- attributes(bikes$temp_feel_centered) %>%\n  set_names(janitor::make_clean_names(names(.)))\n\ntheme_set(theme_minimal())\n\n```\n\n\nI am going to skip some of this since I did it a bit ago. \n\n\n\n```{r}\n\nstan_dat <- bikes |>\n  select(rides, temp_feel_c) |>\n  compose_data()\n\n\njust_temp <- \"\ndata {\nint <lower=1> n;\nvector[n] temp_feel_c;\nvector[n] rides;\n\n}\n\nparameters {\nreal alpha;\nreal beta;\nreal <lower=0> sigma;\n\n}\n\ntransformed parameters {\n\nvector[n] mu;\n\nmu = alpha + beta * temp_feel_c;\n}\n\nmodel {\n\n\nrides ~ normal(mu, sigma);\n\ntemp_feel_c ~ normal(100, 40);\n\nsigma ~ exponential(0.0008);\n\nalpha ~ normal(5000, 1000);\n\n\n}\ngenerated quantities {\n\nvector[n] y_reps;\n\nfor(i in 1:n){\n\ny_reps[i] = normal_rng(mu[i], sigma);\n\n}\n}\n\"\n\nwrite_stan_file(\n  just_temp,\n  \"bayes-rules/linear-regression/stan-scripts/\",\n  \"simple\"\n)\n\nsimple_mod <- cmdstan_model(\n  \"bayes-rules/linear-regression/stan-scripts/simple.stan\"\n)\n\n\nfitted_model <- simple_mod$sample(\n  data = stan_dat,\n  iter_warmup = 5000,\n  iter_sampling = 5000\n)\n\ndraws <- fitted_model$draws(format = \"df\")\n\n\n``` \n\n\n\nCool lets get some posterior draws \n\n\n\n```{r}\n\ndraws |>\n  gather_draws(alpha, beta, sigma) |>\n  ggplot(aes(x = .value, fill = .variable)) +\n  stat_halfeye(normalize = \"xy\") +\n  facet_wrap(vars(.variable), scales = \"free_x\")\n\n```\n\n\nWe can build `linpred_draws` by doing this \n\n```{r}\n\npredicted_draws <- draws |>\n  spread_draws(mu[i], sigma) |>\n  mean_qi() |>\n  mutate(preds = rnorm(n(), mu, sigma)) |>\n  bind_cols(bikes)\n\n\nggplot(predicted_draws, aes(x = temp_feel, y = preds)) +\n  geom_point() +\n  geom_line(aes(y = mu)) +\n  geom_ribbon(aes(ymin = mu.lower, ymax = mu.upper))\n\n```\n\n\nCool now lets see how good this is on the posterior prediction front. \n\n\n\n```{r}\n\ncheck_draws <- draws |>\n  spread_draws(alpha, sigma, beta) |>\n  slice_sample(n = 25) |>\n  mutate(\n    id = 1:n(),\n    mu = map2(.x = alpha, .y = beta, .f = ~ .x + .y * bikes$temp_feel_c),\n    y_rep = map2(mu, sigma, ~ rnorm(500, .x, .y))\n  ) |>\n  unnest(y_rep)\n\n\nggplot() +\n  geom_density(\n    data = check_draws,\n    aes(group = id, x = y_rep),\n    color = \"pink\",\n    alpha = 0.5,\n    linewidth = 0.25\n  ) +\n  geom_density(data = bikes, aes(x = rides), color = \"darkblue\", size = 1)\n\n```\n\n\n\nShe looks okay. We get the mean and the tails somewhat okay but we don't really capture some of the interesting part of the data e.g. we don't capture much or any of the bimodal parts of the data. \n\n\n\nSo we are going to check these against the stuff that Andrew is doing. We are now officially far from home. \n\n\n\n```{r}\n\nclrs <- MetBrewer::met.brewer(\"Lakota\", 6)\ntheme_set(theme_bw())\n\n# Seed stuff\nset.seed(1234)\nBAYES_SEED <- 1234\n\ndata(weather_WU, package = \"bayesrules\")\n\nweather_WU <- weather_WU %>%\n  select(location, windspeed9am, humidity9am, pressure9am, temp9am, temp3pm) |>\n  mutate(across(\n    c(temp9am, temp3pm, humidity9am, windspeed9am, pressure9am),\n    \\(x) scale(x, scale = FALSE),\n    .names = \"{col}_centered\"\n  )) |>\n  mutate(across(\n    c(temp9am, temp3pm, humidity9am, windspeed9am, pressure9am),\n    \\(x) as.numeric(scale(x, scale = FALSE)),\n    .names = \"{col}_c\"\n  ))\n\nextract_attributes <- function(x) {\n  attributes(x) %>%\n    set_names(janitor::make_clean_names(names(.))) %>%\n    as_tibble() %>%\n    slice(1)\n}\n\nunscaled <- weather_WU %>%\n  select(ends_with(\"_centered\")) |>\n  summarize(across(everything(), ~ extract_attributes(.))) |>\n  pivot_longer(everything()) |>\n  unnest(value) |>\n  split(~name)\n\nstan_data <- weather_WU |>\n  select(\n    temp3pm,\n    temp9am_c,\n    humidity9am_c,\n    windspeed9am_c,\n    pressure9am_c,\n    location\n  ) |>\n  compose_data()\n\n\n```\n\n\n### Categorical weather \n\n\n\n```{r}\n\npriors <- c(\n  prior(normal(0, 10), class = b, coef = \"locationWollongong\"),\n  prior(normal(0, 10), class = b, coef = \"locationUluru\"),\n  prior(exponential(1), class = sigma)\n)\n\nweather_location_only_prior_brms <- brm(\n  bf(temp3pm ~ 0 + location),\n  data = weather_WU,\n  family = gaussian(),\n  prior = priors,\n  chains = 4,\n  iter = 5000 * 2,\n  seed = BAYES_SEED,\n  backend = \"cmdstanr\",\n  refresh = 0\n)\n\n\ncat_mod <- \"\ndata {\nint <lower = 0> n;\nint <lower = 1> n_location;\narray[n] int location;\nvector[n] temp3pm;\n\n}\nparameters {\nvector[n_location] beta;\nreal <lower=0> sigma;\n\n}\ntransformed parameters {\nvector[n] mu;\nfor(i in 1:n){\nmu[i] = beta[location[i]];\n\n}\n}\n\nmodel {\n\ntemp3pm ~ normal(mu, sigma);\n\nbeta ~ normal(0, 10);\nsigma ~ exponential(1);\n\n}\ngenerated quantities {\n\nvector[n] y_rep;\n\nfor(i in 1:n){\ny_rep[i] = normal_rng(mu[i], sigma);\n\n}\n\n}\n\n\n\"\nwrite_stan_file(\n  cat_mod,\n  \"bayes-rules/linear-regression/stan-scripts/\",\n  \"cat-mod\"\n)\n\n\ntemp_cat <- cmdstan_model(\n  \"bayes-rules/linear-regression/stan-scripts/cat-mod.stan\"\n)\n\nfit_mod <- temp_cat$sample(data = stan_data, iter_sampling = 5000 * 2)\n\n\n```\n\n\nOkay lets compare the models. \n\n\n\n```{r}\nweather_location_only_prior_brms |>\n  broom.mixed::tidy()\n\nfit_mod$print(\"beta\")\n\n\n```\n\nLets go!!! Lets replicate the actual model that Andrew uses \n\n\n\n```{r}\npriors2 <- c(\n  prior(normal(25, 5), class = Intercept),\n  prior(normal(0, 10), class = b, coef = \"locationWollongong\"),\n  prior(exponential(1), class = sigma)\n)\n\nweather_location_only_prior_brms2 <- brm(\n  bf(temp3pm ~ location),\n  data = weather_WU,\n  family = gaussian(),\n  prior = priors2,\n  chains = 4,\n  iter = 5000 * 2,\n  seed = BAYES_SEED,\n  backend = \"cmdstanr\",\n  refresh = 0\n)\n\n\ncat_mod2 <- \"\ndata {\nint <lower = 0> n;\nint <lower = 1> n_location;\narray[n] int<lower=1, upper=n_location> location;\nvector[n] temp3pm;\n\n}\nparameters {\nreal alpha;\nvector[n_location -1] beta_raw;\nreal <lower=0> sigma;\n\n}\ntransformed parameters {\nvector[n_location] beta;\nvector[n] mu;\n beta[1] = 0; // reference level (e.g., oloroo)\n  for (j in 2:n_location) {\n    beta[j] = beta_raw[j - 1];\n  }\n\n  for (i in 1:n) {\n    mu[i] = alpha + beta[location[i]];\n  }\n\n}\n\nmodel {\n\ntemp3pm ~ normal(mu, sigma);\n\nbeta ~ normal(0, 10);\nsigma ~ exponential(1);\n\n}\ngenerated quantities {\n\nvector[n] y_rep;\n\nfor(i in 1:n){\ny_rep[i] = normal_rng(mu[i], sigma);\n\n}\n\n}\n\n\n\"\nwrite_stan_file(\n  cat_mod2,\n  \"bayes-rules/linear-regression/stan-scripts/\",\n  \"cat-mod2\"\n)\n\n\ntemp_cat2 <- cmdstan_model(\n  \"bayes-rules/linear-regression/stan-scripts/cat-mod2.stan\"\n)\n\nfit_mod2 <- temp_cat2$sample(stan_data)\n\n```\n\n\n\n\n```{r}\n\nweather_location_only_prior_brms2 |>\n  broom.mixed::tidy()\n\nfit_mod2$print()\n\n\n```\n\nThese are more or less similar. \n\n```{r}\n\ndraws <- fit_mod2$draws(format = \"df\") |>\n  select(-`beta[1]`) |>\n  gather_draws(alpha, sigma, beta[i])\n\n\nggplot(draws, aes(x = .value, fill = .variable)) +\n  stat_halfeye(normalize = \"xy\") +\n  facet_wrap(vars(.variable), scales = \"free_x\")\n\n```\n\ncool this matches Andrew's plot fairly well. Now lets grab the posterior predictive checks for both models.\n\n\n\n```{r}\n\nweather_WU <- weather_WU |>\n  mutate(location_2 = ifelse(location == \"Uluru\", 0, 1))\n\n\npost_draws1 <- fit_mod2$draws(format = \"df\") |>\n  select(-`beta[1]`) |>\n  spread_draws(alpha, beta[i], sigma) |>\n  slice_sample(n = 25) |>\n  mutate(\n    id = 1:n(),\n    mu = map2(.x = alpha, .y = beta, .f = ~ .x + .y * weather_WU$location_2),\n    y_rep = map2(mu, sigma, ~ rnorm(200, .x, .y))\n  ) |>\n  unnest(y_rep)\n\nggplot(post_draws1, aes(x = y_rep)) +\n  geom_density(aes(group = id), color = \"pink\", ) +\n  geom_density(data = weather_WU, aes(x = temp3pm))\n\n```\n\nCool the posterior predictive check looks about the same. \n\n\n\nNow its time to get the predicted draws. We do need some trickery to get the predictions \n\n\n\n```{r}\n\npred_draws_cat <- fit_mod2$draws(format = \"df\") |>\n  spread_draws(alpha, `beta[2]`, sigma) |>\n  mutate(\n    wollong = alpha + `beta[2]` * 1,\n    wollong = rnorm(n(), wollong, sigma),\n    uluru = rnorm(n(), alpha, sigma)\n  ) |>\n  pivot_longer(c(wollong, uluru), names_to = \"location\", values_to = \"value\")\n\nggplot(pred_draws_cat, aes(x = value, y = location, fill = location)) +\n  stat_halfeye()\n\n\n```\n\n## Multiple predictors \n\n\n\n```{r}\n\nstan_dat2 <- weather_WU |>\n  select(location, temp9am_c, temp3pm) |>\n  compose_data()\n\nmult_var <- \"\ndata {\nint <lower = 0> n;\nint <lower = 1> n_location;\narray[n] int location;\nvector[n] temp3pm;\nvector[n] temp9am_c;\n\n}\nparameters {\nvector[n_location] beta_location;\nreal beta_temp;\nreal <lower = 0> sigma;\n\n}\ntransformed parameters {\nvector[n] mu;\n\nfor(i in 1:n){\n\nmu[i] = beta_location[location[i]] + beta_temp * temp9am_c[i];\n\n}\n}\n\nmodel {\n\ntemp3pm ~ normal(mu, sigma);\n\nbeta_location ~ normal(0, 10);\nbeta_temp ~ normal(0, 2.5);\nsigma ~ exponential(1);\n\n}\ngenerated quantities {\n\nvector[n] y_rep;\n\nfor(i in 1:n){\ny_rep[i] = normal_rng(mu[i], sigma);\n\n}\n\n}\n\n\n\"\n\n\nwrite_stan_file(\n  mult_var,\n  \"bayes-rules/linear-regression/stan-scripts/\",\n  \"mult-var\"\n)\n\nmult_var_mod <- cmdstan_model(\n  \"bayes-rules/linear-regression/stan-scripts/mult-var.stan\"\n)\n\nmult_var_fit <- mult_var_mod$sample(data = stan_dat2)\n\n\npriors <- c(\n  prior(normal(0, 2.5), class = b, coef = \"temp9am_c\"),\n  prior(normal(0, 10), class = b, coef = \"locationWollongong\"),\n  prior(normal(0, 10), class = b, coef = \"locationUluru\"),\n  prior(exponential(1), class = sigma)\n)\n\n\nmult_var_brms <- brm(\n  bf(temp3pm ~ 0 + location + temp9am_c),\n  data = weather_WU,\n  family = gaussian(),\n  prior = priors,\n  chains = 4,\n  iter = 5000 * 2,\n  seed = BAYES_SEED,\n  backend = \"cmdstanr\",\n  refresh = 0\n)\n\n```\n\nCool lets make sure we get the same output\n\n```{r}\nmult_var_fit$print()\n\nbroom.mixed::tidy(\n  mult_var_brms\n)\n```\n\nThese are fairly similar.\n\n\n\n```{r}\ndrws_df <- mult_var_fit$draws(format = \"df\") |>\n  rename(Uluru = `beta_location[1]`, Woolong = `beta_location[2]`) |>\n  gather_draws(Uluru, Woolong, sigma, beta_temp)\n\nggplot(drws_df, aes(x = .value, fill = .variable)) +\n  stat_halfeye(normalize = \"xy\") +\n  facet_wrap(vars(.variable), scales = \"free_x\")\n\n```\n\n\nCool this is the plot we get from the cmdstan \n\n\n```{r}\n\nmult_var_brms |>\n  gather_draws(b_locationUluru, b_locationWollongong, b_temp9am_c, sigma) |>\n  ggplot(aes(x = .value, fill = .variable)) +\n  stat_halfeye(normalize = \"xy\") +\n  facet_wrap(vars(.variable), scales = \"free_x\")\n\n\n```\n\nThese are more or less the same now lets recreate some of the other plots. Lets look at the posterior. \n\n\n```{r}\n\nweather_WU <- weather_WU |>\n  mutate(location_2 = ifelse(location == \"Uluru\", 1, 2))\n\npost_draws2 <- mult_var_fit$draws(format = \"df\") |>\n  spread_draws(mu[i], sigma, beta_temp) |>\n  slice_sample(n = 25) |>\n  mutate(\n    id = 1:n(),\n    y_rep = map2(mu, sigma, ~ rnorm(200, .x, .y))\n  ) |>\n  unnest(y_rep)\n\n\nggplot(post_draws2, aes(x = y_rep)) +\n  geom_density(aes(group = id), color = \"pink\") +\n  geom_density(data = weather_WU, aes(x = temp3pm))\n\n\n```\n\nAlright now! \n\n\n## Interaction time \n\n\n```{r}\n\nint_model <- \"\ndata {\nint <lower = 0> n;\nint <lower =1> n_location;\narray[n] int location;\nvector[n] temp3pm;\nvector[n] temp9am_c;\n\n}\nparameters {\nreal <lower=0> sigma;\nvector[n_location] beta_location;\nvector [n_location] beta_temp;\n\n}\ntransformed parameters {\nvector[n] mu;\nmu = beta_location[location] + beta_temp[location] .* temp9am_c;\n\n\n}\nmodel {\n\ntemp3pm ~ normal(mu, sigma);\n\nbeta_location ~ normal(0, 10);\nbeta_temp ~ normal(0, 2.5);\nsigma ~ exponential(1);\n\n}\ngenerated quantities {\n\nvector[n] y_rep;\n\nfor(i in 1:n){\ny_rep[i] = normal_rng(mu[i], sigma);\n\n}\n\n}\"\n\nwrite_stan_file(\n  int_model,\n  \"bayes-rules/linear-regression/stan-scripts/\",\n  \"int-model\"\n)\n\n\nint_mod <- cmdstan_model(\n  \"bayes-rules/linear-regression/stan-scripts/int-model.stan\"\n)\n\nfitted_int_mod <- int_mod$sample(data = stan_dat2)\n\n\n```\n\n\nNow lets compare it to an equivelent brooms model. \n\n\n```{r}\npriors <- c(\n  prior(normal(0, 2.5), class = b, nlpar = a), # temp prior\n  prior(normal(0, 10), class = b, nlpar = b), # location prior\n  prior(exponential(1), class = sigma)\n)\n\nint_model_brms <- brm(\n  bf(\n    temp3pm ~ 0 + a + b * temp9am_c,\n    a ~ 0 + location,\n    b ~ 0 + location,\n    nl = TRUE\n  ),\n  prior = priors,\n  data = weather_WU\n)\n\n```\n\nWe should get roughly the same answer\n\n\n```{r}\n\nbroom.mixed::tidy(int_model_brms)\n\nfitted_int_mod$print()\n\n```\n\n\n\n## Going crazy \n\n\nSince we need some practice doing no intercepts and intercepts lets go ahead and do both \n\n\n\n```{r}\n\nfull_mod_no_intercepts <- \"\ndata{\nint <lower=0> n;\nint <lower=1> n_location;\narray[n] int location;\nvector[n] temp3pm;\nvector[n] temp9am_c;\nvector[n] humidity9am_c;\nvector[n] pressure9am_c;\nvector[n] windspeed9am_c;\n}\nparameters {\nreal <lower=0> sigma;\nvector[n_location] beta_location;\nreal beta_temp;\nreal beta_humidity;\nreal beta_pressure;\nreal beta_wind;\n}\ntransformed parameters {\nvector[n] mu;\n\nfor(i in 1:n){\n\nmu[i] = beta_location[location[i]] + beta_temp * temp9am_c[i] + beta_humidity * humidity9am_c[i] + beta_pressure * pressure9am_c[i]+ beta_wind * windspeed9am_c[i];\n\n}\n\n}\n\nmodel {\n\ntemp3pm ~ normal(mu, sigma);\n\nbeta_location ~ normal(0, 10);\n\n[beta_temp, beta_humidity, beta_pressure, beta_wind] ~ normal(0, 2.5);\n\nsigma ~ exponential(1);\n\n\n}\n\ngenerated quantities {\nvector[n] yrep;\n\nfor(i in 1:n){\nyrep[i] = normal_rng(mu[i], sigma);\n\n}\n\n\n}\n\"\n\nwrite_stan_file(\n  full_mod_no_intercepts,\n  dir = \"bayes-rules/linear-regression/stan-scripts/\",\n  basename = \"full-mod\"\n)\n\nfull_mod <- cmdstan_model(\n  \"bayes-rules/linear-regression/stan-scripts/full-mod.stan\"\n)\n\n\nfitted_full_mod <- full_mod$sample(stan_data)\n\npriors <- c(\n  prior(normal(0, 10), class = b, coef = \"locationWollongong\"),\n  prior(normal(0, 10), class = b, coef = \"locationUluru\"),\n  prior(normal(0, 2.5), class = b),\n  prior(exponential(1), class = sigma)\n)\n\nweather_full_brms <- brm(\n  bf(\n    temp3pm ~\n      0 + temp9am_c + humidity9am_c + windspeed9am_c + pressure9am_c + location\n  ),\n  data = weather_WU,\n  family = gaussian(),\n  prior = priors,\n  chains = 4,\n  iter = 5000 * 2,\n  seed = BAYES_SEED,\n  backend = \"cmdstanr\",\n  refresh = 0\n)\n\n\n```\n\n\nNow lets compare \n\n\n\n```{r}\n\ntidy_full_mod <- broom.mixed::tidy(\n  weather_full_brms\n) |>\n  select(term, estimate) |>\n  mutate(\n    term = str_remove(term, \"_c|location\"),\n    term = case_match(\n      term,\n      \"temp9am\" ~ \"temp\",\n      \"humidity9am\" ~ \"humdity\",\n      \"windspeed9am\" ~ \"wind\",\n      \"pressure9am\" ~ \"pressure\",\n      \"Wollongong\" ~ \"Wollongon\",\n      \"Uluru\" ~ \"Uluru\"\n    )\n  ) |>\n  slice(-7) |>\n  arrange(term) |>\n  select(brms = estimate)\n\ncmdstan <- fitted_full_mod$draws(format = \"df\") |>\n  rename(Uluru = `beta_location[1]`, Wollongong = `beta_location[2]`) |>\n  select(Uluru:beta_wind) |>\n  summarise_draws() |>\n  mutate(term = str_remove(variable, \"beta_\")) |>\n  select(term, Cmdstan = mean) |>\n  arrange(term) |>\n  bind_cols(tidy_full_mod)\n\n\nlibrary(tinytable)\n\ntt(cmdstan)\n\n```\n\n\nCool our models are like as close to similar as we could want them.","srcMarkdownNoYaml":"\n\n\n```{r}\nlibrary(bayesrules)\nlibrary(tidyverse)\nlibrary(brms)\nlibrary(cmdstanr)\nlibrary(broom.mixed)\nlibrary(tidybayes)\nlibrary(ggdist)\nlibrary(patchwork)\nlibrary(ggtext)\n\nset.seed(1994)\n\ndata(bikes, package = \"bayesrules\")\n\n\nbikes <- bikes |>\n  mutate(\n    temp_feel_centered = scale(temp_feel, scale = FALSE),\n    temp_feel_c = as.numeric(temp_feel_centered)\n  )\n\n\ntemp_details <- attributes(bikes$temp_feel_centered) %>%\n  set_names(janitor::make_clean_names(names(.)))\n\ntheme_set(theme_minimal())\n\n```\n\n\nI am going to skip some of this since I did it a bit ago. \n\n\n\n```{r}\n\nstan_dat <- bikes |>\n  select(rides, temp_feel_c) |>\n  compose_data()\n\n\njust_temp <- \"\ndata {\nint <lower=1> n;\nvector[n] temp_feel_c;\nvector[n] rides;\n\n}\n\nparameters {\nreal alpha;\nreal beta;\nreal <lower=0> sigma;\n\n}\n\ntransformed parameters {\n\nvector[n] mu;\n\nmu = alpha + beta * temp_feel_c;\n}\n\nmodel {\n\n\nrides ~ normal(mu, sigma);\n\ntemp_feel_c ~ normal(100, 40);\n\nsigma ~ exponential(0.0008);\n\nalpha ~ normal(5000, 1000);\n\n\n}\ngenerated quantities {\n\nvector[n] y_reps;\n\nfor(i in 1:n){\n\ny_reps[i] = normal_rng(mu[i], sigma);\n\n}\n}\n\"\n\nwrite_stan_file(\n  just_temp,\n  \"bayes-rules/linear-regression/stan-scripts/\",\n  \"simple\"\n)\n\nsimple_mod <- cmdstan_model(\n  \"bayes-rules/linear-regression/stan-scripts/simple.stan\"\n)\n\n\nfitted_model <- simple_mod$sample(\n  data = stan_dat,\n  iter_warmup = 5000,\n  iter_sampling = 5000\n)\n\ndraws <- fitted_model$draws(format = \"df\")\n\n\n``` \n\n\n\nCool lets get some posterior draws \n\n\n\n```{r}\n\ndraws |>\n  gather_draws(alpha, beta, sigma) |>\n  ggplot(aes(x = .value, fill = .variable)) +\n  stat_halfeye(normalize = \"xy\") +\n  facet_wrap(vars(.variable), scales = \"free_x\")\n\n```\n\n\nWe can build `linpred_draws` by doing this \n\n```{r}\n\npredicted_draws <- draws |>\n  spread_draws(mu[i], sigma) |>\n  mean_qi() |>\n  mutate(preds = rnorm(n(), mu, sigma)) |>\n  bind_cols(bikes)\n\n\nggplot(predicted_draws, aes(x = temp_feel, y = preds)) +\n  geom_point() +\n  geom_line(aes(y = mu)) +\n  geom_ribbon(aes(ymin = mu.lower, ymax = mu.upper))\n\n```\n\n\nCool now lets see how good this is on the posterior prediction front. \n\n\n\n```{r}\n\ncheck_draws <- draws |>\n  spread_draws(alpha, sigma, beta) |>\n  slice_sample(n = 25) |>\n  mutate(\n    id = 1:n(),\n    mu = map2(.x = alpha, .y = beta, .f = ~ .x + .y * bikes$temp_feel_c),\n    y_rep = map2(mu, sigma, ~ rnorm(500, .x, .y))\n  ) |>\n  unnest(y_rep)\n\n\nggplot() +\n  geom_density(\n    data = check_draws,\n    aes(group = id, x = y_rep),\n    color = \"pink\",\n    alpha = 0.5,\n    linewidth = 0.25\n  ) +\n  geom_density(data = bikes, aes(x = rides), color = \"darkblue\", size = 1)\n\n```\n\n\n\nShe looks okay. We get the mean and the tails somewhat okay but we don't really capture some of the interesting part of the data e.g. we don't capture much or any of the bimodal parts of the data. \n\n\n## Tuning  a model. \n\nSo we are going to check these against the stuff that Andrew is doing. We are now officially far from home. \n\n\n\n```{r}\n\nclrs <- MetBrewer::met.brewer(\"Lakota\", 6)\ntheme_set(theme_bw())\n\n# Seed stuff\nset.seed(1234)\nBAYES_SEED <- 1234\n\ndata(weather_WU, package = \"bayesrules\")\n\nweather_WU <- weather_WU %>%\n  select(location, windspeed9am, humidity9am, pressure9am, temp9am, temp3pm) |>\n  mutate(across(\n    c(temp9am, temp3pm, humidity9am, windspeed9am, pressure9am),\n    \\(x) scale(x, scale = FALSE),\n    .names = \"{col}_centered\"\n  )) |>\n  mutate(across(\n    c(temp9am, temp3pm, humidity9am, windspeed9am, pressure9am),\n    \\(x) as.numeric(scale(x, scale = FALSE)),\n    .names = \"{col}_c\"\n  ))\n\nextract_attributes <- function(x) {\n  attributes(x) %>%\n    set_names(janitor::make_clean_names(names(.))) %>%\n    as_tibble() %>%\n    slice(1)\n}\n\nunscaled <- weather_WU %>%\n  select(ends_with(\"_centered\")) |>\n  summarize(across(everything(), ~ extract_attributes(.))) |>\n  pivot_longer(everything()) |>\n  unnest(value) |>\n  split(~name)\n\nstan_data <- weather_WU |>\n  select(\n    temp3pm,\n    temp9am_c,\n    humidity9am_c,\n    windspeed9am_c,\n    pressure9am_c,\n    location\n  ) |>\n  compose_data()\n\n\n```\n\n\n### Categorical weather \n\n\n\n```{r}\n\npriors <- c(\n  prior(normal(0, 10), class = b, coef = \"locationWollongong\"),\n  prior(normal(0, 10), class = b, coef = \"locationUluru\"),\n  prior(exponential(1), class = sigma)\n)\n\nweather_location_only_prior_brms <- brm(\n  bf(temp3pm ~ 0 + location),\n  data = weather_WU,\n  family = gaussian(),\n  prior = priors,\n  chains = 4,\n  iter = 5000 * 2,\n  seed = BAYES_SEED,\n  backend = \"cmdstanr\",\n  refresh = 0\n)\n\n\ncat_mod <- \"\ndata {\nint <lower = 0> n;\nint <lower = 1> n_location;\narray[n] int location;\nvector[n] temp3pm;\n\n}\nparameters {\nvector[n_location] beta;\nreal <lower=0> sigma;\n\n}\ntransformed parameters {\nvector[n] mu;\nfor(i in 1:n){\nmu[i] = beta[location[i]];\n\n}\n}\n\nmodel {\n\ntemp3pm ~ normal(mu, sigma);\n\nbeta ~ normal(0, 10);\nsigma ~ exponential(1);\n\n}\ngenerated quantities {\n\nvector[n] y_rep;\n\nfor(i in 1:n){\ny_rep[i] = normal_rng(mu[i], sigma);\n\n}\n\n}\n\n\n\"\nwrite_stan_file(\n  cat_mod,\n  \"bayes-rules/linear-regression/stan-scripts/\",\n  \"cat-mod\"\n)\n\n\ntemp_cat <- cmdstan_model(\n  \"bayes-rules/linear-regression/stan-scripts/cat-mod.stan\"\n)\n\nfit_mod <- temp_cat$sample(data = stan_data, iter_sampling = 5000 * 2)\n\n\n```\n\n\nOkay lets compare the models. \n\n\n\n```{r}\nweather_location_only_prior_brms |>\n  broom.mixed::tidy()\n\nfit_mod$print(\"beta\")\n\n\n```\n\nLets go!!! Lets replicate the actual model that Andrew uses \n\n\n\n```{r}\npriors2 <- c(\n  prior(normal(25, 5), class = Intercept),\n  prior(normal(0, 10), class = b, coef = \"locationWollongong\"),\n  prior(exponential(1), class = sigma)\n)\n\nweather_location_only_prior_brms2 <- brm(\n  bf(temp3pm ~ location),\n  data = weather_WU,\n  family = gaussian(),\n  prior = priors2,\n  chains = 4,\n  iter = 5000 * 2,\n  seed = BAYES_SEED,\n  backend = \"cmdstanr\",\n  refresh = 0\n)\n\n\ncat_mod2 <- \"\ndata {\nint <lower = 0> n;\nint <lower = 1> n_location;\narray[n] int<lower=1, upper=n_location> location;\nvector[n] temp3pm;\n\n}\nparameters {\nreal alpha;\nvector[n_location -1] beta_raw;\nreal <lower=0> sigma;\n\n}\ntransformed parameters {\nvector[n_location] beta;\nvector[n] mu;\n beta[1] = 0; // reference level (e.g., oloroo)\n  for (j in 2:n_location) {\n    beta[j] = beta_raw[j - 1];\n  }\n\n  for (i in 1:n) {\n    mu[i] = alpha + beta[location[i]];\n  }\n\n}\n\nmodel {\n\ntemp3pm ~ normal(mu, sigma);\n\nbeta ~ normal(0, 10);\nsigma ~ exponential(1);\n\n}\ngenerated quantities {\n\nvector[n] y_rep;\n\nfor(i in 1:n){\ny_rep[i] = normal_rng(mu[i], sigma);\n\n}\n\n}\n\n\n\"\nwrite_stan_file(\n  cat_mod2,\n  \"bayes-rules/linear-regression/stan-scripts/\",\n  \"cat-mod2\"\n)\n\n\ntemp_cat2 <- cmdstan_model(\n  \"bayes-rules/linear-regression/stan-scripts/cat-mod2.stan\"\n)\n\nfit_mod2 <- temp_cat2$sample(stan_data)\n\n```\n\n\n\n\n```{r}\n\nweather_location_only_prior_brms2 |>\n  broom.mixed::tidy()\n\nfit_mod2$print()\n\n\n```\n\nThese are more or less similar. \n\n```{r}\n\ndraws <- fit_mod2$draws(format = \"df\") |>\n  select(-`beta[1]`) |>\n  gather_draws(alpha, sigma, beta[i])\n\n\nggplot(draws, aes(x = .value, fill = .variable)) +\n  stat_halfeye(normalize = \"xy\") +\n  facet_wrap(vars(.variable), scales = \"free_x\")\n\n```\n\ncool this matches Andrew's plot fairly well. Now lets grab the posterior predictive checks for both models.\n\n\n\n```{r}\n\nweather_WU <- weather_WU |>\n  mutate(location_2 = ifelse(location == \"Uluru\", 0, 1))\n\n\npost_draws1 <- fit_mod2$draws(format = \"df\") |>\n  select(-`beta[1]`) |>\n  spread_draws(alpha, beta[i], sigma) |>\n  slice_sample(n = 25) |>\n  mutate(\n    id = 1:n(),\n    mu = map2(.x = alpha, .y = beta, .f = ~ .x + .y * weather_WU$location_2),\n    y_rep = map2(mu, sigma, ~ rnorm(200, .x, .y))\n  ) |>\n  unnest(y_rep)\n\nggplot(post_draws1, aes(x = y_rep)) +\n  geom_density(aes(group = id), color = \"pink\", ) +\n  geom_density(data = weather_WU, aes(x = temp3pm))\n\n```\n\nCool the posterior predictive check looks about the same. \n\n\n\nNow its time to get the predicted draws. We do need some trickery to get the predictions \n\n\n\n```{r}\n\npred_draws_cat <- fit_mod2$draws(format = \"df\") |>\n  spread_draws(alpha, `beta[2]`, sigma) |>\n  mutate(\n    wollong = alpha + `beta[2]` * 1,\n    wollong = rnorm(n(), wollong, sigma),\n    uluru = rnorm(n(), alpha, sigma)\n  ) |>\n  pivot_longer(c(wollong, uluru), names_to = \"location\", values_to = \"value\")\n\nggplot(pred_draws_cat, aes(x = value, y = location, fill = location)) +\n  stat_halfeye()\n\n\n```\n\n## Multiple predictors \n\n\n\n```{r}\n\nstan_dat2 <- weather_WU |>\n  select(location, temp9am_c, temp3pm) |>\n  compose_data()\n\nmult_var <- \"\ndata {\nint <lower = 0> n;\nint <lower = 1> n_location;\narray[n] int location;\nvector[n] temp3pm;\nvector[n] temp9am_c;\n\n}\nparameters {\nvector[n_location] beta_location;\nreal beta_temp;\nreal <lower = 0> sigma;\n\n}\ntransformed parameters {\nvector[n] mu;\n\nfor(i in 1:n){\n\nmu[i] = beta_location[location[i]] + beta_temp * temp9am_c[i];\n\n}\n}\n\nmodel {\n\ntemp3pm ~ normal(mu, sigma);\n\nbeta_location ~ normal(0, 10);\nbeta_temp ~ normal(0, 2.5);\nsigma ~ exponential(1);\n\n}\ngenerated quantities {\n\nvector[n] y_rep;\n\nfor(i in 1:n){\ny_rep[i] = normal_rng(mu[i], sigma);\n\n}\n\n}\n\n\n\"\n\n\nwrite_stan_file(\n  mult_var,\n  \"bayes-rules/linear-regression/stan-scripts/\",\n  \"mult-var\"\n)\n\nmult_var_mod <- cmdstan_model(\n  \"bayes-rules/linear-regression/stan-scripts/mult-var.stan\"\n)\n\nmult_var_fit <- mult_var_mod$sample(data = stan_dat2)\n\n\npriors <- c(\n  prior(normal(0, 2.5), class = b, coef = \"temp9am_c\"),\n  prior(normal(0, 10), class = b, coef = \"locationWollongong\"),\n  prior(normal(0, 10), class = b, coef = \"locationUluru\"),\n  prior(exponential(1), class = sigma)\n)\n\n\nmult_var_brms <- brm(\n  bf(temp3pm ~ 0 + location + temp9am_c),\n  data = weather_WU,\n  family = gaussian(),\n  prior = priors,\n  chains = 4,\n  iter = 5000 * 2,\n  seed = BAYES_SEED,\n  backend = \"cmdstanr\",\n  refresh = 0\n)\n\n```\n\nCool lets make sure we get the same output\n\n```{r}\nmult_var_fit$print()\n\nbroom.mixed::tidy(\n  mult_var_brms\n)\n```\n\nThese are fairly similar.\n\n\n\n```{r}\ndrws_df <- mult_var_fit$draws(format = \"df\") |>\n  rename(Uluru = `beta_location[1]`, Woolong = `beta_location[2]`) |>\n  gather_draws(Uluru, Woolong, sigma, beta_temp)\n\nggplot(drws_df, aes(x = .value, fill = .variable)) +\n  stat_halfeye(normalize = \"xy\") +\n  facet_wrap(vars(.variable), scales = \"free_x\")\n\n```\n\n\nCool this is the plot we get from the cmdstan \n\n\n```{r}\n\nmult_var_brms |>\n  gather_draws(b_locationUluru, b_locationWollongong, b_temp9am_c, sigma) |>\n  ggplot(aes(x = .value, fill = .variable)) +\n  stat_halfeye(normalize = \"xy\") +\n  facet_wrap(vars(.variable), scales = \"free_x\")\n\n\n```\n\nThese are more or less the same now lets recreate some of the other plots. Lets look at the posterior. \n\n\n```{r}\n\nweather_WU <- weather_WU |>\n  mutate(location_2 = ifelse(location == \"Uluru\", 1, 2))\n\npost_draws2 <- mult_var_fit$draws(format = \"df\") |>\n  spread_draws(mu[i], sigma, beta_temp) |>\n  slice_sample(n = 25) |>\n  mutate(\n    id = 1:n(),\n    y_rep = map2(mu, sigma, ~ rnorm(200, .x, .y))\n  ) |>\n  unnest(y_rep)\n\n\nggplot(post_draws2, aes(x = y_rep)) +\n  geom_density(aes(group = id), color = \"pink\") +\n  geom_density(data = weather_WU, aes(x = temp3pm))\n\n\n```\n\nAlright now! \n\n\n## Interaction time \n\n\n```{r}\n\nint_model <- \"\ndata {\nint <lower = 0> n;\nint <lower =1> n_location;\narray[n] int location;\nvector[n] temp3pm;\nvector[n] temp9am_c;\n\n}\nparameters {\nreal <lower=0> sigma;\nvector[n_location] beta_location;\nvector [n_location] beta_temp;\n\n}\ntransformed parameters {\nvector[n] mu;\nmu = beta_location[location] + beta_temp[location] .* temp9am_c;\n\n\n}\nmodel {\n\ntemp3pm ~ normal(mu, sigma);\n\nbeta_location ~ normal(0, 10);\nbeta_temp ~ normal(0, 2.5);\nsigma ~ exponential(1);\n\n}\ngenerated quantities {\n\nvector[n] y_rep;\n\nfor(i in 1:n){\ny_rep[i] = normal_rng(mu[i], sigma);\n\n}\n\n}\"\n\nwrite_stan_file(\n  int_model,\n  \"bayes-rules/linear-regression/stan-scripts/\",\n  \"int-model\"\n)\n\n\nint_mod <- cmdstan_model(\n  \"bayes-rules/linear-regression/stan-scripts/int-model.stan\"\n)\n\nfitted_int_mod <- int_mod$sample(data = stan_dat2)\n\n\n```\n\n\nNow lets compare it to an equivelent brooms model. \n\n\n```{r}\npriors <- c(\n  prior(normal(0, 2.5), class = b, nlpar = a), # temp prior\n  prior(normal(0, 10), class = b, nlpar = b), # location prior\n  prior(exponential(1), class = sigma)\n)\n\nint_model_brms <- brm(\n  bf(\n    temp3pm ~ 0 + a + b * temp9am_c,\n    a ~ 0 + location,\n    b ~ 0 + location,\n    nl = TRUE\n  ),\n  prior = priors,\n  data = weather_WU\n)\n\n```\n\nWe should get roughly the same answer\n\n\n```{r}\n\nbroom.mixed::tidy(int_model_brms)\n\nfitted_int_mod$print()\n\n```\n\n\n\n## Going crazy \n\n\nSince we need some practice doing no intercepts and intercepts lets go ahead and do both \n\n\n\n```{r}\n\nfull_mod_no_intercepts <- \"\ndata{\nint <lower=0> n;\nint <lower=1> n_location;\narray[n] int location;\nvector[n] temp3pm;\nvector[n] temp9am_c;\nvector[n] humidity9am_c;\nvector[n] pressure9am_c;\nvector[n] windspeed9am_c;\n}\nparameters {\nreal <lower=0> sigma;\nvector[n_location] beta_location;\nreal beta_temp;\nreal beta_humidity;\nreal beta_pressure;\nreal beta_wind;\n}\ntransformed parameters {\nvector[n] mu;\n\nfor(i in 1:n){\n\nmu[i] = beta_location[location[i]] + beta_temp * temp9am_c[i] + beta_humidity * humidity9am_c[i] + beta_pressure * pressure9am_c[i]+ beta_wind * windspeed9am_c[i];\n\n}\n\n}\n\nmodel {\n\ntemp3pm ~ normal(mu, sigma);\n\nbeta_location ~ normal(0, 10);\n\n[beta_temp, beta_humidity, beta_pressure, beta_wind] ~ normal(0, 2.5);\n\nsigma ~ exponential(1);\n\n\n}\n\ngenerated quantities {\nvector[n] yrep;\n\nfor(i in 1:n){\nyrep[i] = normal_rng(mu[i], sigma);\n\n}\n\n\n}\n\"\n\nwrite_stan_file(\n  full_mod_no_intercepts,\n  dir = \"bayes-rules/linear-regression/stan-scripts/\",\n  basename = \"full-mod\"\n)\n\nfull_mod <- cmdstan_model(\n  \"bayes-rules/linear-regression/stan-scripts/full-mod.stan\"\n)\n\n\nfitted_full_mod <- full_mod$sample(stan_data)\n\npriors <- c(\n  prior(normal(0, 10), class = b, coef = \"locationWollongong\"),\n  prior(normal(0, 10), class = b, coef = \"locationUluru\"),\n  prior(normal(0, 2.5), class = b),\n  prior(exponential(1), class = sigma)\n)\n\nweather_full_brms <- brm(\n  bf(\n    temp3pm ~\n      0 + temp9am_c + humidity9am_c + windspeed9am_c + pressure9am_c + location\n  ),\n  data = weather_WU,\n  family = gaussian(),\n  prior = priors,\n  chains = 4,\n  iter = 5000 * 2,\n  seed = BAYES_SEED,\n  backend = \"cmdstanr\",\n  refresh = 0\n)\n\n\n```\n\n\nNow lets compare \n\n\n\n```{r}\n\ntidy_full_mod <- broom.mixed::tidy(\n  weather_full_brms\n) |>\n  select(term, estimate) |>\n  mutate(\n    term = str_remove(term, \"_c|location\"),\n    term = case_match(\n      term,\n      \"temp9am\" ~ \"temp\",\n      \"humidity9am\" ~ \"humdity\",\n      \"windspeed9am\" ~ \"wind\",\n      \"pressure9am\" ~ \"pressure\",\n      \"Wollongong\" ~ \"Wollongon\",\n      \"Uluru\" ~ \"Uluru\"\n    )\n  ) |>\n  slice(-7) |>\n  arrange(term) |>\n  select(brms = estimate)\n\ncmdstan <- fitted_full_mod$draws(format = \"df\") |>\n  rename(Uluru = `beta_location[1]`, Wollongong = `beta_location[2]`) |>\n  select(Uluru:beta_wind) |>\n  summarise_draws() |>\n  mutate(term = str_remove(variable, \"beta_\")) |>\n  select(term, Cmdstan = mean) |>\n  arrange(term) |>\n  bind_cols(tidy_full_mod)\n\n\nlibrary(tinytable)\n\ntt(cmdstan)\n\n```\n\n\nCool our models are like as close to similar as we could want them."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"ols.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.22","knitr":{"opts_chunk":{"results":"hide"}},"theme":["cosmo","brand"],"title":"Linear Regression Stan"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}